<h1 id="relatório-trabalho-de-redes-2">Relatório Trabalho de Redes 2</h1>
<h2 id="daniel-henrique-vieira---grr20206889">Daniel Henrique Vieira - GRR20206889</h2>
<h2 id="introdução">Introdução</h2>
<p>Este relatório traz os detalhes da implementação do sistema de Blockchain “MiniCoins” proposto no trabalho da disciplina Rede de Computadores 2, da turma de 2025 do professor Elias Duarte. A implementação foi realizada utilizando a linguagem <em>Python</em> e a biblioteca <em>asyncio</em>.</p>
<h2 id="resumo">Resumo</h2>
<p>A Blockchain “MiniCoins” é composta de um servidor e um cliente. O servidor é responsável por gerenciar a Blockchain e validar transações, enquanto o cliente fica a cargo de enviar blocos com transações a serem adicionadas na Blockchain. Cada bloco enviado pelo cliente deve vir acompanhado de uma <em>hash</em> gerada pelo cliente, como prova de trabalho.</p>
<h2 id="implementação">Implementação</h2>
<p>A conexão realizada entre o servidor e o cliente é feita utilizando <em>websockets</em> com a ajuda da biblioteca <em>asyncio</em> (esta foi adicionada no diretório da implementação, visto que a biblioteca não está disponível nas máquinas do DINF). Para realizar a conexão, podemos tanto utilizar o <em>localhost</em> quanto um IP estabelecido pelo primeiro argumento ao inicializar o servidor/cliente.</p>
<p>Para inicializar com o <em>localhost</em>, utilizamos:</p>
<p>python3 <a href="http://server.py">server.py</a></p>
<p>python3 <a href="http://client.py">client.py</a></p>
<p>Para inicializar com um IP específico, utilizamos:</p>
<p>python3 <a href="http://server.py">server.py</a> &lt;ENDERECO_IP&gt;</p>
<p>python3 <a href="http://client.py">client.py</a> &lt;ENDERECO_IP&gt;</p>
<p>A conexão sempre é feita utilizando a porta 8038.</p>
<p>A implementação da Blockchain possui duas partes principais: o <a href="codigo_txt/server.py.txt"><em>server.py</em></a> e o <a href="codigo_txt/client.py.txt"><em>client.py</em></a>. Ambos os códigos utilizam as classes definidas em <a href="codigo_txt/classes.py.txt"><em>classes.py</em></a>.</p>
<h3 id="classes.py"><em><a href="http://classes.py">classes.py</a></em></h3>
<p>Este arquivo possui a definição das classes utilizadas pela Blockchain. Ao todo, utilizamos três classes na implementação: <em>Transaction</em>, <em>Block</em> e <em>Blockchain</em>.</p>
<h4 id="transaction"><em>Transaction</em></h4>
<p>Classe utilizada para representar uma transação em nossa blockchain.</p>
<p>| Atributo | Tipo | Função |</p>
<p>| – | – | – |</p>
<p>| <em>amount</em> | int | Define a quantia de valor transferido na transação|</p>
<p>| <em>destiny</em> | string | Define o usuário que irá receber o valor da transferência |</p>
<p>| <em>source</em> | string | Define o usuário cujo valor será retirado |</p>
<p>Note que a classe não possui um campo que indica o tipo de transação: todas as transações de nossa Blockchain são transações de transferência, bastando apenas indicar a origem e destino dela.</p>
<p>Caso o cliente deseje “sacar” ou “depositar” uma quantia, basta criar uma instância <em>Transaction</em> com o atributo <em>source</em>/<em>destiny</em> igual a “MiniCoins” (o nome de usuário do servidor).</p>
<h4 id="block"><em>Block</em></h4>
<p>Classe utilizada para representar um bloco com transação armazenado em nossa</p>
<p>| Atributo | Tipo | Função |</p>
<p>| – | – | – |</p>
<p>| <em>transaction</em> | Transaction | Transação armazenada no bloco|</p>
<p>| <em>previous_hash</em> | string | Hash do bloco antecessor deste bloco |</p>
<p>| <em>timestamp</em> | datetime | Data e hora da criação do bloco |</p>
<p>| <em>nonce</em> | int | Valor inteiro aleatório definido na criação de um hash válido |</p>
<p>|<em>hash</em>|string|Hash do bloco|</p>
<p>|<em>next_block</em>|<em>Block</em>|O bloco posterior a este|</p>
<h5 id="geração-da-hash">Geração da <em>hash</em></h5>
<p>O hash de um bloco é definido (quase) sempre na inicialização de uma instância dessa classe. A única exceção é quando desejamos reconstruir um bloco.</p>
<p>A geração do hash (que é feita pelo método <a href="codigo_txt/utils.py.txt"><em>utils.py</em></a>)é feita utilizando os campos da <em>transaction</em>, a <em>previous_hash</em>, o <em>timestamp</em> e o valor <em>nonce</em>, todos unificados em um string único que é então criptografado. O valor de <em>nonce</em> é gerado aleatoriamente, e, em seguida, é incrementado de um em um até que um hash válido seja alcançado. Em nossa Blockchain, um hash é considerado válido se ele iniciar com a substring “038”.</p>
<h4 id="blockchain"><em>Blockchain</em></h4>
<p>Diferente das outras classes, este se encontra no arquivo <a href="codigo_txt/blockchain.py.txt"><em>blockchain.py</em></a>. Esta classe contém a lógica principal de nossa Blockchain, e é responsável por armazenar e validar os blocos das transações.</p>
<p>| Atributo | Tipo | Função |</p>
<p>| – | – | – |</p>
<p>| <em>first_block</em> | Block | Primeiro bloco da Blockchain|</p>
<h5 id="adicionando-blocos">Adicionando blocos</h5>
<p>Para adicionar um bloco na Blockchain, a Blockchain primeiro faz duas validações: primeiro, verifica se a operação a adicionar é válida (a conta cujo valor está sendo transferido possui valor suficiente?) e em seguida, verifica se a <em>hash</em> é válida, comparando a <em>previous_hash</em> do bloco a ser adicionado com a hash do bloco mais recente da Blockchain, além da regra da substring “038”. Caso as duas validações sejam bem-sucedidas, o bloco é anexado ao final da blockchain.</p>
<h3 id="servidor">Servidor</h3>
<p>A responsabilidade do gerenciamento da Blockchain reside completamente no servidor. Ao inicializar, o servidor cria a Blockchain com um bloco único e <em>previous_hash</em> vazio, contendo o valor inicial que transitará pela rede. Após isso, o <em>websocket</em> é aberto e fica disponível para o recebimento de requisições por parte dos clientes.</p>
<p>O tipo de requisição é definido pelo campo inteiro <em>“type”</em> da mensagem. O servidor aceita os seguintes tipos definido pelo arquivo <a href="codigo_txt/settings.py.txt"><em>settings.py</em></a>:</p>
<p>| Configuração | Valor|</p>
<p>| - | - |</p>
<p>| REQUEST_BLOCKCHAIN_HASH | 1 |</p>
<p>| REQUEST_ADD_BLOCK | 2 |</p>
<p>| REQUEST_VERIFY_BLOCKCHAIN | 3 |</p>
<p>Quaisquer outros valores são recusados, resultando no servidor enviando uma mensagem de erro ao cliente que requisitou.</p>
<h4 id="request_blockchain_hash">REQUEST_BLOCKCHAIN_HASH</h4>
<p>Para que o cliente possa gerar uma <em>hash</em> válida, é necessário utilizar a <em>hash</em> do bloco mais recente na Blockchain. A requisição REQUEST_BLOCKCHAIN_HASH indica que o cliente deseja saber qual é a <em>hash</em> mais recente.</p>
<p>Ao receber uma requisição deste tipo, o servidor acessa todos os blocos da Blockchain até chegar ao último bloco, e retorna sua <em>hash</em>. A resposta desse tipo de requisição consiste em:</p>
<p>| Nome|Tipo|Descrição|</p>
<p>|-|-|-|</p>
<p>|status | string | Indica o resultado da requisição (sempre “success”, a não ser que haja uma exceção no código)|</p>
<p>|hash|string|Hash do bloco mais recente da Blockchain|</p>
<h4 id="request_add_block">REQUEST_ADD_BLOCK</h4>
<p>Esse tipo de requisição indica que o cliente deseja adicionar um novo bloco com transação na Blockchain (ver seção Adicionando blocos). A resposta desse tipo de requisição consiste em:</p>
<p>| Nome|Tipo|Descrição|</p>
<p>|-|-|-|</p>
<p>|status | string | Indica o resultado da requisição (“success” em caso de sucesso, “error” caso o bloco não seja válido)|</p>
<p>|message|string|Contém detalhes do resultado da requisição, como motivo do bloco ter sido rejeitado|</p>
<p>Note que a hash do bloco a ser adicionado <strong>não é gerada pelo servidor.</strong> A responsabilidade da geração da hash é totalmente do cliente. Isso é feito para garantir que haja uma prova de trabalho por parte do cliente.</p>
<h4 id="request_verify_blockchain">REQUEST_VERIFY_BLOCKCHAIN</h4>
<p>Esse tipo de requisição indica que o cliente deseja verificar se a Blockchain ainda é válida e não há nenhuma inconsistência nos blocos. Essa verificação é feita com o servidor passando entre cada bloco e comparando suas hashes. A resposta desse tipo de requisição consiste em:</p>
<p>| Nome|Tipo|Descrição|</p>
<p>|-|-|-|</p>
<p>|status | string | Indica o resultado da requisição (“success” em caso de sucesso, “error” caso o bloco não seja válido)|</p>
<p>|message|string|Contém detalhes do resultado da requisição, e em caso de erro, indica o bloco que está comprometido|</p>
<p>Esse tipo de requisição faz com que o servidor gere um <em>log</em> no terminal com as comparações e hashes dos blocos.</p>
<h3 id="cliente">Cliente</h3>
<p>Ao inicializar o cliente, o usuário deve definir seu nome de usuário, que também irá definir sua conta na Blockchain. Com o cliente em execução, podemos escolher a operação que desejamos efetuar. Entre elas, podemos efetuar um “saque”, um “depósito”, uma “transferência” ou uma “verificação da blockchain”.</p>
<h4 id="saque">Saque</h4>
<p>Para efetuar um saque, o cliente deve informar a quantidade que deseja sacar. Então, o cliente solicita a hash do bloco mais recente para que ele possa gerar o bloco para adicionar na Blockchain.</p>
<h5 id="corpo-da-requisição">Corpo da requisição</h5>
<p>|Campo|Valor|Descrição|</p>
<p>|-|-|-|</p>
<p>|type| REQUEST_BLOCKCHAIN_HASH | Indica o tipo de requisição feita para o servidor|</p>
<p>|message|string|Contém detalhes do resultado da requisição, e em caso de erro, indica o bloco que está comprometido|</p>
<p>Feito isso, o cliente envia uma requisição contendo um bloco de transação com o valor desejado, sua própria conta como conta destino e a conta “MiniCoins” como conta de origem.</p>
<h5 id="corpo-da-requisição-1">Corpo da requisição</h5>
<p>| Campo|Valor|Descrição|</p>
<p>|-|-|-|</p>
<p>|type| REQUEST_ADD_BLOCK |Indica o tipo de requisição feita para o servidor|</p>
<p>|block| string contendo o bloco em formato JSON |O bloco a ser adicionado na Blockchain|</p>
<h4 id="depósito">Depósito</h4>
<p>Para efetuar um depósito, o cliente deve informar a quantidade que deseja depositar. Então, o cliente solicita a hash do bloco mais recente para que ele possa gerar o bloco para adicionar na Blockchain.</p>
<h5 id="corpo-da-requisição-2">Corpo da requisição</h5>
<p>|Campo|Valor|Descrição|</p>
<p>|-|-|-|</p>
<p>|type| REQUEST_BLOCKCHAIN_HASH | Indica o tipo de requisição feita para o servidor|</p>
<p>|message|string|Contém detalhes do resultado da requisição, e em caso de erro, indica o bloco que está comprometido|</p>
<p>Feito isso, o cliente envia uma requisição contendo um bloco de transação com o valor desejado, a conta “MiniCoins” como conta destino e sua própria conta como conta de origem.</p>
<h5 id="corpo-da-requisição-3">Corpo da requisição</h5>
<p>| Campo|Valor|Descrição|</p>
<p>|-|-|-|</p>
<p>|type| REQUEST_ADD_BLOCK |Indica o tipo de requisição feita para o servidor|</p>
<p>|block| string contendo o bloco em formato JSON |O bloco a ser adicionado na Blockchain|</p>
<h4 id="transferência">Transferência</h4>
<p>Para efetuar um saque, o cliente deve informar a quantidade que deseja transferir e a conta de destino. Então, o cliente solicita a hash do bloco mais recente para que ele possa gerar o bloco para adicionar na Blockchain.</p>
<h5 id="corpo-da-requisição-4">Corpo da requisição</h5>
<p>|Campo|Valor|Descrição|</p>
<p>|-|-|-|</p>
<p>|type| REQUEST_BLOCKCHAIN_HASH | Indica o tipo de requisição feita para o servidor|</p>
<p>|message|string|Contém detalhes do resultado da requisição, e em caso de erro, indica o bloco que está comprometido|</p>
<p>Feito isso, o cliente envia uma requisição contendo um bloco de transação com o valor desejado, a conta definida como destino e sua própria conta como conta de origem. Note que não é possível realizar uma transferência de outra conta para a conta do próprio cliente (isso seria uma falha de segurança gravíssima).</p>
<h5 id="corpo-da-requisição-5">Corpo da requisição</h5>
<p>| Campo|Valor|Descrição|</p>
<p>|-|-|-|</p>
<p>|type| REQUEST_ADD_BLOCK |Indica o tipo de requisição feita para o servidor|</p>
<p>|block| string contendo o bloco em formato JSON |O bloco a ser adicionado na Blockchain|</p>

